"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("@snyk/lodash");
const pMap = require("p-map");
const _1 = require("./");
const get_node_runtime_version_1 = require("../get-node-runtime-version");
const event_loop_spinner_1 = require("event-loop-spinner");
const errors_1 = require("../errors");
const config_1 = require("../config");
const EVENT_PROCESSING_CONCURRENCY = 5;
class YarnLockParser {
    constructor() {
        // @yarnpkg/lockfile doesn't work with Node.js < 6 and crashes just after
        // the import, so it has to be required conditionally
        // more details at https://github.com/yarnpkg/yarn/issues/6304
        if (get_node_runtime_version_1.default() < 6) {
            throw new errors_1.UnsupportedRuntimeError('yarn.lock parsing is supported for ' + 'Node.js v6 and higher.');
        }
        this.yarnLockfileParser = require('@yarnpkg/lockfile');
        // Number of dependencies including root one.
        this.treeSize = 1;
    }
    parseLockFile(lockFileContents) {
        try {
            const yarnLock = this.yarnLockfileParser.parse(lockFileContents);
            yarnLock.dependencies = yarnLock.object;
            yarnLock.type = _1.LockfileType.yarn;
            return yarnLock;
        }
        catch (e) {
            throw new errors_1.InvalidUserInputError('yarn.lock parsing failed with an ' + `error: ${e.message}`);
        }
    }
    async getDependencyTree(manifestFile, lockfile, includeDev = false, strict = true) {
        if (lockfile.type !== _1.LockfileType.yarn) {
            throw new errors_1.InvalidUserInputError('Unsupported lockfile provided. ' +
                'Please provide `package-lock.json`.');
        }
        const yarnLock = lockfile;
        const depTree = {
            dependencies: {},
            hasDevDependencies: !_.isEmpty(manifestFile.devDependencies),
            name: manifestFile.name,
            size: 1,
            version: manifestFile.version || '',
        };
        const nodeVersion = _.get(manifestFile, 'engines.node');
        if (nodeVersion) {
            _.set(depTree, 'meta.nodeVersion', nodeVersion);
        }
        const topLevelDeps = _1.getTopLevelDeps(manifestFile, includeDev);
        // asked to process empty deps
        if (_.isEmpty(manifestFile.dependencies) && !includeDev) {
            return depTree;
        }
        await pMap(topLevelDeps, (dep) => this.resolveDep(dep, depTree, yarnLock, strict), { concurrency: EVENT_PROCESSING_CONCURRENCY });
        depTree.size = this.treeSize;
        return depTree;
    }
    async buildSubTree(lockFile, tree, strict) {
        const queue = [{ path: [], tree }];
        while (queue.length > 0) {
            const queueItem = queue.pop();
            const depKey = `${queueItem.tree.name}@${queueItem.tree.version}`;
            const dependency = lockFile.object[depKey];
            if (!dependency) {
                if (strict) {
                    throw new errors_1.OutOfSyncError(queueItem.tree.name, 'yarn');
                }
                if (!queueItem.tree.labels) {
                    queueItem.tree.labels = {};
                }
                queueItem.tree.labels.missingLockFileEntry = 'true';
                continue;
            }
            // Overwrite version pattern with exact version.
            queueItem.tree.version = dependency.version;
            if (queueItem.path.indexOf(depKey) >= 0) {
                if (!queueItem.tree.labels) {
                    queueItem.tree.labels = {};
                }
                queueItem.tree.labels.pruned = 'cyclic';
                continue;
            }
            const subDependencies = _.entries(Object.assign(Object.assign({}, dependency.dependencies), dependency.optionalDependencies));
            for (const [subName, subVersion] of subDependencies) {
                // tree size limit should be 6 millions.
                if (this.treeSize > config_1.config.YARN_TREE_SIZE_LIMIT) {
                    throw new errors_1.TreeSizeLimitError();
                }
                const subDependency = {
                    labels: {
                        scope: tree.labels.scope,
                    },
                    name: subName,
                    version: subVersion,
                };
                if (!queueItem.tree.dependencies) {
                    queueItem.tree.dependencies = {};
                }
                queueItem.tree.dependencies[subName] = subDependency;
                queue.push({
                    path: [...queueItem.path, depKey],
                    tree: subDependency,
                });
                this.treeSize++;
                if (event_loop_spinner_1.eventLoopSpinner.isStarving()) {
                    await event_loop_spinner_1.eventLoopSpinner.spin();
                }
            }
        }
        return tree;
    }
    async resolveDep(dep, depTree, yarnLock, strict) {
        if (/^file:/.test(dep.version)) {
            depTree.dependencies[dep.name] = _1.createDepTreeDepFromDep(dep);
        }
        else {
            depTree.dependencies[dep.name] = await this.buildSubTree(yarnLock, _1.createDepTreeDepFromDep(dep), strict);
        }
        this.treeSize++;
        if (event_loop_spinner_1.eventLoopSpinner.isStarving()) {
            await event_loop_spinner_1.eventLoopSpinner.spin();
        }
    }
}
exports.YarnLockParser = YarnLockParser;
//# sourceMappingURL=yarn-lock-parse.js.map